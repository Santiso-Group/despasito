---
title: 'DESPASITO: A Python Package for SAFT EOS Parametrization and Thermodynamic Calculations'
tags:
  - Python
  - thermodynamics
  - equations of state
  - saft
  - coarse-grain
authors:
  - name: Jennifer A. Clark
    orcid: 0000-0003-4897-5651
    affiliation: 1
    corresponding: true
  - name: Nathan Duff
    affiliation: 1
  - name: Andrew Abi-Mansour
    affiliation: 2
  - given-names: Erik E. Santiso
    orcid: 0000-0003-1768-8414
    corresponding: true
    affiliation: 1
affiliations:
 - name: Department of Chemical and Biomolecular Engineering, North Carolina State University, Raleigh, NC, 27695, USA
   index: 1
 - name: The Molecular Sciences Software Institute, Blacksburg, VA, 24060, USA
   index: 2
date: 05 May 2024
bibliography: paper.bib
---

# Summary

DESAPSITO is an open-source Python package that provides access to complex thermodynamic calculations, with a special interest in the statistical associating fluid theory (SAFT) equation of state. The modular design of DESPASITO provides an extensible architecture that could be easily customized or extended by other researchers. The currently supported equations of state (SAFT-$\gamma$-Mie, SAFT-$\gamma$-SW, and Peng-Robinson) thoroughly represent the dynamic use of this platform and its intentional design for expansion. This growth mindset extends into the other modules, as additional thermodynamic calculations and parameter fitting routines may be included. Nonetheless, the current state of DESPASITO can be employed by the simulation community for coarse-grained forcefield development with SAFT-$\gamma$-Mie. The DESPASITO package is available from PyPI and its source code is hosted on GitHub, which provides a platform for community-driven contributions and feedback.

# 1. Statement of Need

To improve on the 20+ years needed between material development and market use [@plunkett_plunketts_2017], theoretical studies have accelerated material design endeavors [@lee_review_2019; @fermeglia_multiscale_2020]. Of the theoretical methods available, coarse-grained molecular dynamics (CG-MD) simulations have gained attention for their ability to access transport and mechanical properties, as well as phase separations of materials [@nikkhah_molecular_2021; @miwatani_performance_2020; @lee_multiscale_2009; @joshi_review_2020]. CG methods represent an atomistic ensemble as a single ‚Äúbead‚Äù that must sufficiently capture the degrees of freedom of the underlying structure to produce realistic results [@fermeglia_multiscale_2020]. Although CG-MD yields computational efficiency in comparison to all-atom molecular dynamics (AA-MD), generating parameters that are representative of the system‚Äôs physics is a continuing struggle. An appealing method of obtaining parameters entails a top-down approach to reproduce some macroscopic property in a simulation. Comparison to macroscopic properties entails an iterative procedure which is time consuming, as many lengthy simulations are needed. 

The SAFT-ùõæ-Mie CG methodology has emerged as an appealing CG formalism as the parameters are linked to the SAFT equation of state (EOS) [@muller_force-field_2014; @pervaje_molecular_2019]. The Statistical Associating Fluid Theory (SAFT) equation of state (EOS) [@chapman_saft_1989; @chapman_new_1990; @chapman_phase_1988] inherently connects macroscopic properties with the nonbonded interactions of segments through the Helmholtz free energy. Details of theory, applications, and limitations of SAFT variants up to this point have been thoroughly described elsewhere [@pervaje_molecular_2019; @tan_recent_2008; @muller_molecular-based_2001; @economou_statistical_2002]. SAFT has been historically applied to the complex fluids encountered by the oil and gas industry as an EOS, but recently it has received attention from computational scientists and engineers for molecular simulations. SAFT has many advantages due to its deep-rooted basis in statistical mechanics. SAFT-$\gamma$ [@muller_force-field_2014; @avendano_saft-_2011; @mejia_force_2014; @ervik_bottled_2016] offers transferable heteronuclear segments that have been developed into a CG formalism  [@papaioannou_simultaneous_2011; @papaioannou_group_2014; @dufal_prediction_2014]. Other homonuclear versions of SAFT have also been applied to molecular simulations [@cardenas_phase_2016; @galliero_thermodynamic_2007; @garrido_interfacial_2016; @sauer_parametric_2003]. Use of SAFT improves CG parametrization, as the parameters fit to an EOS using experimental data can be applied in simulations, avoiding the much more computationally intensive alternative of iterative parametrization simulations with various system conditions. The result is a less computationally intensive methodology yielding chemical specificity. Both SAFT-$\gamma$-Mie [@avendano_saft_2013; @garrido_interfacial_2016-1; @morgado_saft-_2016; @pervaje_modeling_2018; @pervaje_molecular_2020; @walker_development_2019; @walker_extending_2020] and SAFT-$\gamma$-square-well (SW) [@galindo_thermodynamics_1998; @gil-villegas_statistical_1997] have been successfully applied to molecular simulations.

Due, to its complexity, specialized software is needed to use SAFT either as an EOS or to predict simulation parameters. Bottled SAFT [@ervik_bottled_2016] is a web application meant to remedy issues of parametrization by applying corresponding states for homonuclear molecules. This method relies on possessing the critical properties, acentric factor, and liquid density at 0.7 reduced temperature. Once bead parameters are acquired, whether from the literature or by other means, MD simulations can be carried out. Nevertheless, properties derived from simulations using SAFT are usually accompanied by the EOS prediction, reintroducing the need for specialized software. There are three fundamental requirements for a software that uses SAFT. The first is programming the EOS to generate the Helmholtz free energy. Second, thermodynamic functions must use the EOS to generate system properties. Third, a parametrization package should support both the EOS and thermodynamic functions to facilitate parameter fitting to macroscopic data. Writing this software is not a trivial task and serves as a barrier in development and application of related research. For a specific variant, PC-SAFT, the commercial package, Aspen, handles thermodynamic calculations and parameter estimation. Similarly, the commercial package gSAFT from Process Systems Enterprise, PSE, supports SAFT-$\gamma$-Mie. Another open-source thermodynamic package, CoolProp [@bell_pure_2014] has been working toward implementing PC-SAFT [@gross_perturbed-chain_2001; @dominik_modeling_2005; @tihic_applications_2006]. Additionally, a Python package [@baird_pcsaft_2021] that handles thermodynamic calculations with PC-SAFT was developed in the same time period as this work. That Python package is based on a set of open-source MATLAB scripts [@martin_teaching_2011] that support the original SAFT implementation and PC-SAFT. However, these open-source options do not support parametrization. To produce an open-source software that fulfills the three requirements, this work describes the Python package: Determining Equilibrium State and Parametrization Application for SAFT, Intended for Thermodynamic Output (DESPASITO) [@clark_despasito_2021].

Herein, we describe DESPASITO, a tool that (1) performs thermodynamic calculations of complex mixtures and (2) fits parameters to experimental data with the potential of accelerating and improving CG simulation research. DESPASITO is capable of reproducing studies published by groups with similar codes [@muller_force-field_2014; @avendano_saft-_2011; @avendano_saft_2013; @garrido_interfacial_2016-1; @morgado_saft-_2016; @herdes_coarse_2015; @herdes_predicting_2016; @mejia_use_2014; @lobanova_saft-_2016]. Although DESPASITO focuses on the SAFT-$\gamma$ variant, it is equipped with general thermodynamic and parameterization modules that any supported EOS can use. In creating this platform to fit parameters for the SAFT EOS, we consequently equipped DESPASITO to handle other equations of state that cannot be solved explicitly. This platform is designed to allow easy and intuitive extension of each module and supported features. It is our purpose to build a base that will supply community accessibility to complex thermodynamic calculations.

# 2. Implementation and Architecture

## 2.1 Overview

The central purpose of DESPASITO is to calculate thermodynamic properties with equations of state (EOS). This package is implemented in the Python 3 programming language with four modules that use a combination of procedural and object-oriented approaches. DESPASITO incorporates the features supplied by the MolSSI Computational Molecular Science Python Cookiecutter [@naden_cookiecutter_2024] (e.g., git, continuous integration, pytest, and readthedocs). The simplest use of DESPASITO involves passing a JSON input file to the command-line interface (CLI), which reads an input file and distributes relevant input data to appropriate modules. An input file may contain instructions for either a thermodynamic or parameter fitting calculation. Alternatively, DESPASITO can be used as a library via its application programming interface (API) for designing complex workflows. In the following sections we will first discuss the CLI, and in the subsequent sections discuss the API as it pertains to the core modules: *Equations of State*, *Thermodynamics*, and *Parameter Fitting*.

## 2.2 Command-Line Interface

DESPASITO provides a CLI that is useful when it is executed as a program. This simplifies the user experience as calculations are initiated in an input file. Here we describe some differences between the two interfaces. Once the input file is assembled, a calculation is submitted with:
    ``python -m despasito -i input.json``
The input file uses the JSON format to import the relevant information as a dictionary and then distributes relevant information to the other modules. Upon completing the provided instructions, the results are written to an output file. At a minimum, the input file contains a definition of the molecular components (i.e., bead definitions and quantities) and the bead self- and cross-interaction parameter files in the JSON format, as well the required instructions for either a thermodynamic or parameter fitting calculation. Whether the input file contains instructions for a thermodynamic or parameter fitting calculation is indicated by the presence of the keyword `optimization_parameters`. This section must then be accompanied by dictionaries containing experimental data and thermodynamic calculation requirements for a specific `data_class_type` defined within the dictionary structure. When defining experimental data, a user may list the relevant data in arrays within the input file or include the path to a comma separated file. Rather than further elaborating on the input keyword options or definitions here, the interested user will find the package documentation and tutorials useful. The ability to initiate either a thermodynamic or parameter fitting calculation from a single input file fosters a simple user experience for two complex processes. The logic followed by the CLI is summarized in Figure 1. This diagram shows two workflows that cover typical calculations. However, a user may choose to use DESPASITO as a library to construct a customized workflow or use the module components individually.

![Flowchart of `despasito.main.run`, the function called by the command line interface. This process can distinguish between a thermodynamic and parameter fitting calculation. The colors orange, red, green, and purple, respectively represent the input_output, equations_of_state, thermodynamics, and parameter_fitting modules. Gray color indicates actions taken within `despasito.main.run`.\label{fig:figure1}](Figures/Figure1.png)

## 2.3 Computations Available in Current Version

The currently available capabilities in DESPASITO (v0.3.0) can be separated into three categories: *Equations of State*, *Thermodynamics*, and *Parameter Fitting*. Each of these categories is distinguished in this package as a separate module. Here we will summarize the options available to each category (i.e., module), supplemented with knowledge of program architecture where necessary.

Currently three EOSs are supported in DESPASITO: SAFT- $\gamma$-Mie [@avendano_saft_2013; @garrido_interfacial_2016-1; @morgado_saft-_2016; @pervaje_modeling_2018; @pervaje_molecular_2020; @walker_development_2019; @walker_extending_2020], SAFT- $\gamma$-SW [@galindo_thermodynamics_1998; @gil-villegas_statistical_1997], and Peng-Robinson [@peng_new_1976]. The latter was included as an example of an implementation of a non-SAFT EOS to demonstrate the extensible design in DESPASITO. An EOS object can encapsulate a variety of equations of state, and any compatible EOS object can interact with the *Thermodynamics* and *Parameter Fitting* modules. Details of EOS classes are elaborated on in Section 2.4. Even though DESPASITO is sufficient for CG-MD development with SAFT-ùõæ-Mie or SAFT-ùõæ-SW, the current EOS options are admittedly limited. Adding another EOS, or family is straightforward in DESPASITO. Further details can be found in the Reuse Policy section or in the documentation. 

DESPASITO provides accessibility to many common thermodynamic calculation types, such as: multicomponent bubble point and dew point, binary flash, Hildebrand solubility, as well as vapor, liquid, and saturation properties. We also included a `verify_eos` function to carry out thermodynamic consistency tests for contributed EOSs. Our EOS classes are equipped to handle any number of components, however, some of the thermodynamic calculations are only robust for binary fluids (i.e., bubble point and dew point). Modeling binary systems with this set of thermodynamic calculations are sufficient for our initial purpose in fitting interaction parameters from experimental data. Second derivative properties are a priority in the next release.

To fit parameters to experimental data, many options are available to refine the process. A user can customize the parameter fitting routine by defining the objective functional form, choosing a global optimization method and its associated options, refining minimization method and its associated options, and defining nonlinear constraints. The default global optimization method is differential evolution, although many others are available as shown in Table 1. The custom method, `grid_minimization`, is based off the `scipy` optimization function, `brute`. Like `brute`, a grid of parameter values is created, but in this custom function the parameter sets are then changed with a minimization route to fit the experimental data. Some parameters can also be frozen. For example, a grid of two parameters may be defined, while those remaining are minimized. Global optimization of EOS parameters is agnostic to the EOS or thermodynamic data being used. Like the EOS is encapsulated in an object, the thermodynamic calculations are also abstracted from the parameter fitting process with Data classes. The Data class passes updates EOS parameters and returns the objective value used in the fitting procedure. The available data classes supported by DESPASITO, are found in Table 1. Further details on Data classes can be found in the Reuse Policy section or documentation.

## 2.4 Application Programming Interface

DESPASITO provides an application programming interface (API) where the capabilities of each of the core modules (i.e., *Equations of State*, *Thermodynamics*, and *Parameter Fitting*) may be accessed through their respective entry-points shown in Table 2. The *Equations of State* module is meant to supply an EOS object with a consistent set of methods exposed for the convenience of the *Thermodynamics* and *Parameter Fitting* modules. Other methods may be included for the internal function of the EOS object or independent use as an imported library. For the *Thermodynamics* module, any supported thermodynamic calculation can be computed through its entry point given the system information and an EOS object. The result of a thermodynamic calculation is a dictionary of both the system inputs and calculated outputs. The entry-point for the *Parameter Fitting* module handles both the interaction between EOS objects and thermodynamic calculations and the interaction between thermodynamic calculations and an objective function used in the parameter fitting method. These interactions are handled with the initiation of a `Data` class for each dataset. However, because each dataset may represent a different molecular composition containing a common target bead, they must have an EOS object initiated beforehand. With these three core functions the major features of DESPASITO can be imported and used as a library.

Aside from the entry-points for the core modules previously described, the *Input / Output* module provides the functionality of importing and exporting the JSON files handled in by the CLI. Additionally, logging can be enabled to view intermediate values with the function, `despasito.initiate_logger`. Although all functions in DESPASITO are accessible to the user, we expect the functions described in this section to have streamlined the majority of use cases.

Although the outcome from using module entry-points for the *Thermodynamic* and *Parameter Fitting* modules are comparable to the CLI use of DESPASITO, exposing an EOS object and its available methods can have broader use cases. Figure 2 shows the inheritance structure of EOS classes in DESPASITO using an abstract template class to standardize EOS object methods and attributes. This standardization ensures compatibility with the *Thermodynamics* and *Parameter Fitting* modules. The SAFT EOS object uses another level of organization. As described earlier, SAFT relates nonbonded interactions to macroscopic properties through the Helmholtz free energy. Contributions to the Helmholtz free energy are segmented into terms, often these include the ideal, monomer, chain, and association site contributions. However, different SAFT variants may or may not include other terms (e.g. electrostatic and solvation terms [@shahriari_new_2018] or polar terms [@dominik_modeling_2005]). Often the ideal and association terms are consistent throughout the variants of SAFT and so are grouped in a common SAFT class, while the others are expressed in a `SaftType` class. An EOS object can be initiated, by using DESPASITO as a library, to allow each of these contributions to be handled individually. The *Parameter Fitting* module uses an abstract template class to standardize experimental `Data` classes. The role of Data objects is to handle EOS and thermodynamic calculations and output an objective value representing the ability of a given parameter set to reproduce experimental data.

![UML diagram of *Equation of State* classes used in DESPASITO. Required attributes and methods are shown in abstract class templates. Other methods and attributes are removed for clarity, except in the special case of SAFT. Here we illustrate how the common Helmholtz energy contributions are expressed in a shared class, while the specialized contributions of a SAFT variant are contained in an imported object.\label{fig:figure2}](Figures/Figure2.png)

## 2.5 Compiled Modules

Operational speed can be increased with the optional use of compiled code within EOS classes. Apart from the association site contribution of the SAFT EOS, DESPASITO defaults to a pure Python implementation for the supported EOSs. It is heavily recommended that the association term calculation is then computed using `cython` or `numba`. The `method_stat` class is passed to an EOS class to indicate which method should be used. First, the keyword `numba` initiates just-in-time compilation for EOS functions with that supported option. Second, the `cython` flag initiates use of supported EOS functions that were optionally compiled upon installation. Third, the `python` flag signals that only Python should be used, *including* association site calculations, although its use is not recommended except for an exercise in patience. All three of these options have been implemented for the SAFT- ùõæ-Mie EOS.

## 2.6 Parallelization

Thermodynamic calculations of the same type can be run in parallel. Python is equipped with a shared memory multiprocessing module that is handled in the utility directory, `despasito.utils`. Here, the `MultiprocessingJob` class handles initiation of a processing pool, calculation dispatch, individual thread logging and consolidation into a job log. The addition of this shared memory utility allows a large set of calculations to run in parallel using high-performance computing (HPC) resources. Both the *Thermodynamics* and *Parameter Fitting* modules are equipped to use this class. If given numerous state conditions at which to perform a thermodynamic calculation (e.g., a list of liquid compositions to perform bubble point calculations), the calculations would be split and reassembled by the multiprocessing pool. A parameter fitting procedure may use the multiprocessing class in one of two ways. First, a single parameter set could be assessed at a time, where the thermodynamic calculations needed to compare to experimental data are split among the processing threads. Although, if a population of parameter sets are to be assessed for every iteration (as in differential evolution), the multiprocessing object may split the evaluation of the parameter sets among the processing threads. If the global algorithm supports workers, this is the default behavior.

# 3. Additional Features: Prediction of Cross-Interaction Parameters for SAFT-$\gamma$-Mie

DESPASITO is equipped to predict cross-interaction parameters (between segments of different types) using the open-source package, Multipole Approach of Predicting and Scaling Cross Interactions (MAPSCI) [@clark_mapsci_2020] as a plug-in. As the name implies, MAPSCI uses the multipole moments of molecular fragments in conjunction with their SAFT self-interaction parameters to estimate their cross-interactions. Currently, this package supports SAFT-ùõæ-Mie. Use of this plugin reduces the degrees of freedom during parametrization, as SAFT self-interaction parameters are often fit to experimental data, and cross-interaction parameters usually require mixture data. Relying purely on experimental data for cross-interaction parameters is difficult due to the combinatorial explosion in the number of interaction parameters needed for an increasing number of components. MAPSCI is based on a derivation of the combining rules (in this case applied to SAFT-ùõæ-Mie) that were extended to utilize multipole moments of molecular fragments.[@clark_saft-mie_2021] Although the multipole moments from small molecules can be found experimentally, the multipole moments of fragments can be derived from density functional theory (DFT) [@clark_saft-mie_2021]. The difficulty in coarse-graining systems while retaining chemical specificity is a constant challenge that we seek to remedy.

# 4. Quality Control

Initial EOS development and module verification has been achieved through replicating the thermodynamic and parameter fitting results for existing publications. Unit testing is available through `pytest`, where continuous integration of MacOS, Windows, and Linux are handled by GitHub Actions. For each operating system, Python 3.10, 3.11, and 3.12 are tested. These tests cover over fifty percent of the package according to `codecov`. Much of what is unaccounted for includes exception handling and redundant functions for alternative compilation through Numba and Cython.

# Acknowledgements

We thank Jacob Kausler for his aid in logging multiple processes.

# Funding statement 

Jennifer Clark was supported by a fellowship from The Molecular Sciences Software Institute under NSF grant OAC-1547580.

# References